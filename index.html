<!DOCTYPE html>
<html>
<head>
    <title>Chakra Tracker</title>
    <style>
        body { font-family: sans-serif; }
        #messageArea { margin-top: 10px; color: red; }
        #jutsuItems li { cursor: context-menu; }
    </style>
</head>
<body>
    <h1>Chakra Tracker</h1>
    <div>
        Max Chakra: <input type="number" id="maxChakra" value="10">
        Replenish Rate: <input type="number" id="replenishRate" value="0">
        <button onclick="initializeTracker()">Initialize</button>
    </div>
    <div id="chakraInfo">
        Current Chakra: <span id="currentChakra">0</span>/<span id="maxChakraDisplay">0</span>
    </div>
    <div>
        Jutsu Name: <input type="text" id="jutsuName">
        Chakra Cost: <input type="number" id="jutsuCost">
    </div>
    <div>
        Jutsu to Use: <input type="text" id="jutsuToUse">
        <button onclick="useJutsu()">Use Jutsu</button>
    </div>
    <div>
        <button onclick="displayJutsuList()">Display Jutsu List</button>
        <button onclick="recoverChakra()">Recover Chakra</button>
    </div>
    <div id="jutsuList">
        <h2>Available Jutsu:</h2>
        <ul id="jutsuItems"></ul>
    </div>
    <div id="messageArea"></div>

    <script>
        let chakraTracker;
        const messageArea = document.getElementById("messageArea");
        const maxChakraInput = document.getElementById("maxChakra");
        const replenishRateInput = document.getElementById("replenishRate");
        const jutsuNameInput = document.getElementById("jutsuName");
        const jutsuCostInput = document.getElementById("jutsuCost");

        function displayMessage(message, isError = true) {
            messageArea.textContent = message;
            messageArea.style.color = isError ? "red" : "green";
        }

        function initializeTracker() {
            const maxChakra = parseInt(maxChakraInput.value);
            const replenishRate = parseFloat(replenishRateInput.value);

            if (isNaN(maxChakra) || maxChakra <= 0) {
                displayMessage("Invalid Max Chakra.", true);
                return;
            }
            if (isNaN(replenishRate) || replenishRate < 0) {
                displayMessage("Invalid Replenish Rate.", true);
                return;
            }

            chakraTracker = new ChakraTracker(maxChakra, replenishRate);
            updateDisplay();
            saveData();
        }

        class ChakraTracker {
            constructor(maxChakra, replenishRate = 0) {
                this.maxChakra = maxChakra;
                this.replenishRate = replenishRate;
                this.currentChakra = this.maxChakra;
                this.lastReplenishTime = Date.now();
                this.jutsuList = JSON.parse(localStorage.getItem('jutsuList')) || {};
            }

            // ... (Other ChakraTracker methods - same as before)

            addJutsu() {
                const jutsuName = jutsuNameInput.value;
                const chakraCost = parseInt(jutsuCostInput.value);

                if (!jutsuName || isNaN(chakraCost) || chakraCost <= 0) {
                    displayMessage("Invalid jutsu name or chakra cost.", true);
                    return;
                }

                this.jutsuList[jutsuName] = chakraCost;
                displayJutsuList();
                saveData();
                jutsuNameInput.value = "";
                jutsuCostInput.value = "";
                displayMessage("Jutsu added successfully!", false);
            }

            removeJutsu(jutsuToRemove) {
                if (this.jutsuList[jutsuToRemove]) {
                    delete this.jutsuList[jutsuToRemove];
                    displayJutsuList();
                    saveData();
                    displayMessage("Jutsu removed successfully!", false);
                } else {
                    displayMessage("Jutsu not found.", true);
                }
            }

            displayJutsuList() {
                const jutsuListElement = document.getElementById("jutsuItems");
                jutsuListElement.innerHTML = "";

                for (const jutsu in this.jutsuList) {
                    const li = document.createElement("li");
                    li.textContent = `${jutsu}: ${this.jutsuList[jutsu]} chakra`;
                    li.addEventListener('contextmenu', (event) => {
                        event.preventDefault();
                        if (confirm(`Delete ${jutsu}?`)) {
                            chakraTracker.removeJutsu(jutsu);
                        }
                    });
                    jutsuListElement.appendChild(li);
                }
            }
        }

        function saveData() {
            if (chakraTracker) {
                localStorage.setItem('maxChakra', chakraTracker.maxChakra);
                localStorage.setItem('replenishRate', chakraTracker.replenishRate);
                localStorage.setItem('jutsuList', JSON.stringify(chakraTracker.jutsuList));
            }
        }

        function loadData() {
            const savedMaxChakra = localStorage.getItem('maxChakra');
            const savedReplenishRate = localStorage.getItem('replenishRate');

            if (savedMaxChakra && savedReplenishRate) {
                maxChakraInput.value = savedMaxChakra;
                replenishRateInput.value = savedReplenishRate;
                initializeTracker();
            }
        }

        function updateDisplay() {
            if (chakraTracker) {
                chakraTracker.replenish();
                document.getElementById("currentChakra").textContent = chakraTracker.currentChakra;
                document.getElementById("maxChakraDisplay").textContent = chakraTracker.maxChakra;
            }
        }

        jutsuCostInput.addEventListener("keyup", function(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                if (chakraTracker) { // Corrected this line
                    chakraTracker.addJutsu();
                }
            }
        });

        loadData();
        setInterval(updateDisplay, 1000);
    </script>
</body>
</html>
